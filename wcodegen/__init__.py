"""\
Common code used by all widget code generators

@copyright: 2013-2014 Carsten Grohmann
@license: MIT (see license.txt) - THIS PROGRAM COMES WITH NO WARRANTY
"""

import common

import copy
import logging
import types


class BaseCodeWriterBase(object):
    """\
    Base class for all code writer classes.

    @ivar _logger: Instance specific logger
    """

    language = None
    """\
    Language generated by this code generator

    @type: String
    """

    lang_prefix = None
    """\
    Language prefix to use in filenames to specify language specific code.

    @type: String
    """

    def __init__(self):
        """\
        Initialise only instance variables using there defaults.
        """
        # initialise instance logger
        self._logger = logging.getLogger(self.__class__.__name__)

    def __getstate__(self):
        state = self.__dict__.copy()
        del state['_logger']
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)

        # re-initialise logger instance deleted from __getstate__
        self._logger = logging.getLogger(self.__class__.__name__)

# end of class BaseCodeWriterBase


class BaseWidgetCodeWriter(BaseCodeWriterBase):
    """\
    Base class for all widget code writer classes.

    @ivar codegen: Language specific code generator
    @type codegen: Instance of L{codegen.BaseLangCodeWriter}

    @ivar config: Widgets specific configuration (see L{common.widget_config})
    @type config: Dictionary

    @ivar klass: wxWidgets class name
    @type klass: String or None
    """

    default_style = None
    """\
    Default widget style in wxWidget notation.

    @type: String
    @see: L{set_default_style}
    @see: L{prefix_style}
    """

    extra_headers = []
    """\
    List of extra header file, in the form <header.h> or "header.h" or an
    empty list.

    Example::
        extra_headers = ['<wx/treectrl.h>']

    @type: List of strings
    """

    lang_styles = {}
    """
    Language specific widget style settings. This settings will merged with
    the generic settings stored in L{common.widget_config}.

    @type: Dictionary
    @see: L{common.widget_config}
    """

    supported_by = ()
    """\
    This widget is only available at the listed wx versions. An empty list
    means the widgets is always available.

    Example for a widgets introduced with wx 2.8::
        supported_by = ((2, 8), (3, 0))

    @type: List of tuples with major and minor wx version number
    @see: L{wxglade.codegen.BaseLangCodeWriter.for_version}
    """

    tmpl_after = []
    """\
    Template for instructions to execute after the widget is initialised

    @type: List of strings
    @see: L{tmpl_before}
    """

    tmpl_before = []
    """\
    Template for instructions to execute before the widget is initialised

    @type: List of strings
    @see: L{tmpl_after}
    """

    tmpl_layout = []
    """\
    Template to set widget layout

    @type: List of strings
    """

    tmpl_props = []
    """\
    Template to set widget properties

    @type: List of strings
    """

    tmpl = ''
    """\
    Template to create a new instance of a new wxWidget object.

    @type: String
    @see: L{get_code()}
    @see: L{tmpl_dict}
    """

    tmpl_dict = {}
    """\
    Content to replace in the templates

    @type: Dictionary
    @see: L{tmpl}
    @see: L{tmpl_before}
    @see: L{tmpl_props}
    """

    has_choice = False
    """\
    Flag to handle widgets with choices

    @type: Boolean
    @see: L{_prepare_choice()}
    """

    has_selection = False
    """\
    Flag to create a C{SetSelection(...)} call.

    @type: Boolean
    @see: L{tmpl_selection}
    """

    tmpl_selection = ''
    """\
    Template to create a C{SetSelection(...)} call.

    @type: String
    @see: L{has_selection}
    """

    has_setdefault = False
    """\
    Flag to create a C{SetDefault()} call.

    @type: Boolean
    """

    tmpl_setdefault = ''
    """\
    Template to create a C{SetDefault()} call.

    @type: String
    """

    has_setvalue = False
    """\
    Flag to create a C{SetValue(...)} call.

    @type: Boolean
    @see: L{tmpl_setvalue}
    @see: L{has_setvalue1}
    """

    has_setvalue1 = False
    """\
    Flag to create a C{SetValue(1)} call.

    @type: Boolean
    @see: L{tmpl_setvalue}
    @see: L{has_setvalue}
    """

    tmpl_setvalue = ''
    """\
    Template to create a C{SetValue(...)} call.

    @type: String
    @see: L{has_setvalue}
    @see: L{has_setvalue1}
    """

    prefix_style = False
    """\
    Prepend wxDefaultPosition and wxDefaultSize to the widget style if the
    style will be set.

    @type: Boolean
    @see: L{default_style}
    @see: L{set_default_style}
    """

    set_default_style = False
    """\
    Flag to to add the default style always. The default style won't added
    generally.

    @type: Boolean
    @see: L{default_style}
    @see: L{prefix_style}
    """

    def __init__(self, klass=None):
        # call inherited constructor
        BaseCodeWriterBase.__init__(self)
        self.config = {}
        self.klass = None

        # All copy operation of styles uses always a deep-copy to prevent
        # changing original data

        # merge generic specific styles
        self.config['styles'] = copy.deepcopy(
            common.widget_config['generic_styles'])

        # merge widget specific settings
        if klass and klass in common.widget_config:
            self.klass = klass
            for item in common.widget_config[self.klass]:
                if item == 'styles':
                    try:
                        self.config[item].update(copy.deepcopy(
                            common.widget_config[self.klass]['styles']))
                    except KeyError:
                        pass
                else:
                    self.config[item] = \
                        copy.deepcopy(common.widget_config[self.klass][item]
                    )

        # merge language specific styles
        if self.lang_styles:
            self.config['styles'].update(self.lang_styles)

        # convert 'combination' from string to set
        for style in self.config['styles'].keys():
            try:
                self.config['styles'][style]['combination'] = set(
                    self.config['styles'][style]['combination'].split('|')
                )
            except KeyError:
                pass

        self.codegen = common.code_writers[self.language]
        self._reset_vars()

    def stmt2list(self, stmt):
        """\
        Split a code statement into a list by conserving tailing newlines

        Example::
            >>> tmpl2list('line 1\\nline 2\\nline 3\\n')
            ['line 1\\n', 'line 2\\n', 'line 3\\n', '\\n']

        @param stmt: Code statement
        @type stmt:  String

        @rtype: List of strings
        """
        temp = ['%s\n' % line for line in stmt.split('\n')]
        return temp

    def _reset_vars(self):
        """\
        Reset instance variables back to defaults
        """
        self.has_selection = False
        self.has_setdefault = False
        self.has_setvalue = False
        self.has_setvalue1 = False
        self.tmpl_before = []
        self.tmpl_after = []
        self.tmpl_layout = []
        self.tmpl_props = []
        self.tmpl_dict = {}

    def _prepare_tmpl_content(self, obj):
        """\
        Prepare and set template variables.

        @param obj: Instance of L{xml_parse.CodeObject}

        @rtype: Dictionary
        @see: L{get_code()}
        """
        self.tmpl_dict['comment'] = self.codegen.comment_sign
        self.tmpl_dict['tab'] = self.codegen.tabs(1)
        self.tmpl_dict['store_as_attr'] = self.codegen.test_attribute(obj)
        self.tmpl_dict['id_name'], self.tmpl_dict['id_number'] = \
            self.codegen.generate_code_id(obj)
        self.tmpl_dict['id'] = self.tmpl_dict['id_number']
        self.tmpl_dict['obj_name'] = obj.name

        klass = obj.klass
        if klass == obj.base:
            klass = self.cn(klass)
        self.tmpl_dict['klass'] = klass

        self.tmpl_dict['store_as_attr'] = self.codegen.test_attribute(obj)

        prop = obj.properties
        style = prop.get('style', '')
        if style and style != self.default_style:
            style = '%s' % self.cn_f(style)
        else:
            if self.set_default_style:
                style = '%s' % self.cn_f(self.default_style)
            else:
                style = ''

        if style and self.prefix_style:
            style = ', %s, %s, %s' % (
                self.cn('wxDefaultPosition'),
                self.cn('wxDefaultSize'),
                style,
            )
        self.tmpl_dict['style'] = style

        self.tmpl_dict['label'] = self.codegen.quote_str(prop.get('label', ''))
        self.tmpl_dict['value'] = self.codegen.quote_str(prop.get('value', ''))
        self.tmpl_dict['value_unquoted'] = prop.get('value', '')

        return

    def _prepare_choice(self, obj):
        """\
        Prepare choices for widgets with choices

        @param obj: Instance of L{xml_parse.CodeObject}

        @rtype: Dictionary
        @see: L{get_code()}
        @see: L{has_choice}
        """
        choices = obj.properties.get('choices', [])
        choices = ', '.join([self.codegen.quote_str(c) for c in choices])
        self.tmpl_dict['choices'] = choices
        self.tmpl_dict['choices_len'] = len(choices)

        selection = obj.properties.get('selection', None)
        if selection is not None and choices:
            self.tmpl_dict['selection'] = selection
            self.has_selection = True
        return

    def cn(self, name):
        return self.codegen.cn(name)

    def cn_f(self, flags):
        try:
            return self.codegen.cn_f(flags, self.config['styles'])
        except KeyError:
            return self.codegen.cn_f(flags)

    def get_code(self, obj):
        """\
        Generates language specific code for the wxWidget object from a
        template by filling variables generated by L{_prepare_tmpl_content()}.

        @see: L{_prepare_tmpl_content()}
        """
        assert self.tmpl or obj.klass == 'spacer'
        init_lines = []
        self._reset_vars()

        # spacers are generally handled by a hack:
        # The the implementations of add_sizeritem() contains more details.
        if obj.klass == 'spacer':
            width = obj.properties.get('width', '0')
            height = obj.properties.get('height', '0')
            obj.name = '%s, %s' % (width, height)
            return [], [], []

        self._prepare_tmpl_content(obj)

        if self.has_choice:
            self._prepare_choice(obj)

        if self.tmpl_dict['id_name']:
            init_lines.append(self.tmpl_dict['id_name'])

        if self.tmpl_before:
            for line in self.tmpl_before:
                init_lines.append(line % self.tmpl_dict)

        init_lines.append(self.tmpl % self.tmpl_dict)

        if self.tmpl_after:
            for line in self.tmpl_after:
                init_lines.append(line % self.tmpl_dict)

        prop_lines = self.codegen.generate_common_properties(obj)

        if self.tmpl_props:
            for line in self.tmpl_props:
                prop_lines.append(line % self.tmpl_dict)

        if self.has_setvalue1:
            assert self.tmpl_setvalue
            assert not self.has_setvalue
            self.tmpl_dict['value_unquoted'] = '1'
            prop_lines.append(self.tmpl_setvalue % self.tmpl_dict)

        if self.has_setvalue and self.tmpl_dict['value_unquoted']:
            assert self.tmpl_setvalue
            assert not self.has_setvalue1
            prop_lines.append(self.tmpl_setvalue % self.tmpl_dict)

        if self.has_setdefault:
            assert self.tmpl_setdefault
            prop_lines.append(self.tmpl_setdefault % self.tmpl_dict)

        if self.has_selection:
            assert self.tmpl_selection
            prop_lines.append(self.tmpl_selection % self.tmpl_dict)

        if not self.tmpl_dict['store_as_attr']:
            # the object doesn't have to be stored as an attribute of the
            # custom class, but it is just considered part of the layout
            return [], [], init_lines + prop_lines
        return init_lines, prop_lines, []


    def get_properties_code(self, obj):
        """\
        Generates language specific code to set properties for the wxWidget
        object from a template by filling variables generated by
        L{_prepare_tmpl_content()}.

        @see: L{_prepare_tmpl_content()}
        @see: L{tmpl_props}
        @rtype: List of strings
        """
        assert self.tmpl_props
        prop_lines = []
        self._reset_vars()

        self._prepare_tmpl_content(obj)

        for line in self.tmpl_props:
            prop_lines.append(line % self.tmpl_dict)

        return prop_lines

    def get_layout_code(self, obj):
        """\
        Generates language specific code to create the layout for the
        wxWidget object from a template by filling variables generated by
        L{_prepare_tmpl_content()}.

        @see: L{_prepare_tmpl_content()}
        @see: L{tmpl_props}
        @rtype: List of strings
        """
        assert self.tmpl_layout
        layout_lines = []
        self._reset_vars()

        self._prepare_tmpl_content(obj)

        for line in self.tmpl_layout:
            layout_lines.append(line % self.tmpl_dict)

        return layout_lines

    def is_supported(self, major, minor=None):
        """\
        Check if the widget is supported for the given version

        @param major: Major version number
        @type major:  Integer
        @param minor: Minor version number
        @type minor:  Integer

        @return: True if the widget is supported by the specified wx version
        @rtype:  Boolean

        @see: L{common.widget_config}
        """
        assert isinstance(major, types.IntType)
        assert isinstance(minor, (types.IntType, types.NoneType))

        # no restrictions exists
        if 'supported_by' not in self.config:
            return True

        if minor:
            version_specific = 'wx%s%s' % (major, minor)
            if version_specific in self.config['supported_by']:
                return True

        version_generic = 'wx%s' % major
        if version_generic in self.config['supported_by']:
            return True

        return False

# end of class BaseWidgetCodeWriter


class CppWidgetCodeWriter(BaseWidgetCodeWriter):
    """\
    Base class for all C++ widget code writer classes.
    """
    prefix_style = True
    language = 'C++'
    lang_prefix = 'cpp'
    tmpl_setvalue = '%(name)s->SetValue(%(value_unquoted)s);\n'
    tmpl_setdefault = '%(name)s->SetDefault();\n'
    tmpl_selection = '%(name)s->SetSelection(%(selection)s);\n'

    def _prepare_choice(self, obj):
        choices = obj.properties.get('choices', [])
        self.tmpl_dict['choices_len'] = len(choices)

        selection = obj.properties.get('selection', None)
        if selection is not None and choices:
            self.tmpl_dict['selection'] = selection
            self.has_selection = True

        if len(choices):
            self.tmpl_before.append('const wxString %(name)s_choices[] = {\n')
            for choice in choices:
                self.tmpl_before.append(
                    '%s%s,\n' % (
                        self.codegen.tabs(1),
                        self.codegen.quote_str(choice),
                    )
                )
            self.tmpl_before.append('};\n')
        else:
            self.tmpl_before.append(
                'const wxString *%(name)s_choices = NULL;\n'
            )

        return

    def _prepare_tmpl_content(self, obj):
        BaseWidgetCodeWriter._prepare_tmpl_content(self, obj)

        if not obj.parent.is_toplevel:
            self.tmpl_dict['parent'] = '%s' % obj.parent.name
        else:
            self.tmpl_dict['parent'] = 'this'

        if self.tmpl_dict['store_as_attr']:
            self.tmpl_dict['name'] = self.codegen._format_classattr(obj)
        else:
            self.tmpl_dict['name'] = '%s* %s' % (obj.klass, obj.name)

        return

    def get_code(self, obj):
        init, props_buf, layout = BaseWidgetCodeWriter.get_code(self, obj)

        # default get_code() returns a tuple of three lists (init, properties
        # and layout).
        # But CPP get_code() returns a tuple of four lists (init, ids,
        # properties and layout).
        id_name = self.codegen.generate_code_id(obj)[0]
        if id_name:
            ids = [id_name]
        else:
            ids = []

        return init, ids, props_buf, layout

# end of class CppWidgetCodeWriter


class LispWidgetCodeWriter(BaseWidgetCodeWriter):
    """\
    Base class for all Lisp widget code writer classes.
    """
    language = 'lisp'
    lang_prefix = 'lisp'
    tmpl_setvalue = '(%(klass)s_SetValue %(name)s %(value_unquoted)s)\n'
    tmpl_setdefault = '(%(klass)s_SetDefault %(name)s)\n'
    tmpl_selection = '(%(klass)s_SetSelection %(name)s %(selection)s)\n'

    def _prepare_choice(self, obj):
        choices = obj.properties.get('choices', [])
        self.tmpl_dict['choices_len'] = len(choices)
        self.tmpl_dict['choices'] = ' '.join([self.codegen.quote_str(c) for c in choices])

        selection = obj.properties.get('selection', None)
        if selection is not None and choices:
            self.tmpl_dict['selection'] = selection
            self.has_selection = True
        return

    def _prepare_tmpl_content(self, obj):
        BaseWidgetCodeWriter._prepare_tmpl_content(self, obj)

        if not obj.parent.is_toplevel:
            self.tmpl_dict['parent'] = '(slot-%s obj)' % obj.parent.name
        else:
            self.tmpl_dict['parent'] = '(slot-top-window obj)'

        if not self.tmpl_dict['style']:
            self.tmpl_dict['style'] = '0'

        # Lisp stores all widgets as class attributes
        self.tmpl_dict['name'] = '(%s obj)' % self.codegen._format_classattr(obj)

        return

# end of class LispWidgetCodeWriter


class PerlWidgetCodeWriter(BaseWidgetCodeWriter):
    """\
    Base class for all Perl widget code writer classes.
    """
    prefix_style = True
    language = 'perl'
    lang_prefix = 'perl'
    tmpl_setvalue = '%(name)s->SetValue(%(value_unquoted)s);\n'
    tmpl_setdefault = '%(name)s->SetDefault();\n'
    tmpl_selection = '%(name)s->SetSelection(%(selection)s);\n'

    def _prepare_tmpl_content(self, obj):
        BaseWidgetCodeWriter._prepare_tmpl_content(self, obj)

        if not obj.parent.is_toplevel:
            parent = '$self->{%s}' % obj.parent.name
        else:
            parent = '$self'

        self.tmpl_dict['parent'] = parent
        if self.tmpl_dict['store_as_attr']:
            name = '$self->{%s}' % obj.name
        else:
            name = 'my $%s' % obj.name
        self.tmpl_dict['name'] = name

        return

# end of class PerlWidgetCodeWriter


class PythonWidgetCodeWriter(BaseWidgetCodeWriter):
    """\
    Base class for all Python widget code writer classes.
    """
    language = 'python'
    lang_prefix = 'py'
    tmpl_setvalue = '%(name)s.SetValue(%(value_unquoted)s)\n'
    tmpl_setdefault = '%(name)s.SetDefault()\n'
    tmpl_selection = '%(name)s.SetSelection(%(selection)s)\n'

    def _prepare_tmpl_content(self, obj):
        BaseWidgetCodeWriter._prepare_tmpl_content(self, obj)

        if not obj.parent.is_toplevel:
            self.tmpl_dict['parent'] = 'self.%s' % obj.parent.name
        else:
            self.tmpl_dict['parent'] = 'self'

        style = obj.properties.get('style', '')
        if style and style != self.default_style:
            style = ', style=%s' % self.cn_f(style)
        else:
            if self.set_default_style:
                style = ', style=%s' % self.cn_f(self.default_style)
            else:
                style = ''
        self.tmpl_dict['style'] = style

        if self.tmpl_dict['store_as_attr']:
            self.tmpl_dict['name'] = self.codegen._format_classattr(obj)
        else:
            self.tmpl_dict['name'] = obj.name

        return

# end of class PythonWidgetCodeWriter
